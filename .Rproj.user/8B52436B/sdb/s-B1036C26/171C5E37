{
    "contents" : "### ============= Useful Visualisations Tools ========================= ###\n\n## ggplot Color Function from http://stackoverflow.com/a/8197703/1659890\ngg_color_hue <- function(n) {\n  hues = seq(15, 375, length = n + 1)\n  hcl(h = hues, l = 65, c = 100)[1:n]\n}\n\n### ====================================== Whole Network Page: UI ============================================\n### =================================================================================================================\n\nusefulCols_life_events <- c(\"Primary.Participant.Name\",\"Secondary.Participant.Name\",\"Event.or.Relationship.Type\",\n                            \"Category\",\"DateOne.Year\", \"DateOne.Month\", \"DateOne.Day\",\"DateOne.Uncertainty\",\"DateTwo.Year\",                 \n                            \"DateTwo.Month\", \"DateTwo.Day\",\"DateTwo.Uncertainty\",\"Date.Type\",\"Location.Details\",\"Location.Region\",\n                            \"Location.Country\",\"Textual.Source.Source\")\n\n### ========= show/hide advanced options for the whole network\n\n# shinyjs::onclick(\"toggleDateOptions\",\n#                  shinyjs::toggle(id = \"dateOptions\", anim = TRUE)) \n\n# shinyjs::onclick(\"toggleAdditionalOptions\",\n#                  shinyjs::toggle(id = \"additionalOptions\", anim = TRUE)) \n\n### ========= Exclude entries without a date\n\n# output$include_interactions_without_dates_UI <- renderUI({\n#   checkboxInput(inputId = \"include_interactions_without_dates\", label = \"Include interactions without dates?\", value = FALSE)\n# })\n\n### ========= Category/Type Selection UI Elements\n\nall_event_types <- reactive(levels(multiparty.interactions$Event.or.Relationship.Type))\nall_event_categories <- reactive(levels(multiparty.interactions$Category))\n\n### ====================================== Generate Edges Function ============================================\n### =================================================================================================================\n\nnetwork.edges.function <- function(selected.interactions){\n  \n  edges.of.network <- data.frame(\"Primary.Emlo_ID\" = character(),\n                                 \"Secondary.Emlo_ID\" = character(),\n                                 \"EcclesiasticalActivities\" = character(),\n                                 \"EducationalActivities\" = numeric(),\n                                 \"FamilyRelationships\" = numeric(),\n                                 \"HierarchicalRelationships\" = numeric(),\n                                 \"LearnedActivities\" = numeric(),\n                                 \"MajorLifeEvents\"= numeric(),\n                                 \"PeerRelationships\" = numeric(),\n                                 \"PoliticalActivities\" = numeric(),\n                                 \"ProfessionalActivities\" = numeric(),\n                                 \"SocialStatusChange\" = numeric()\n  )\n  # Find unique connections (relying on EMLO_ID)\n  unique_Connections <- unique(selected.interactions[,c(\"Primary.Participant.Emlo_ID\",\"Secondary.Participant.Emlo_ID\")])\n  # Split into a list for easier usage in lapply operations later!\n  unique_Connections <- split(unique_Connections, seq(nrow(unique_Connections)))\n\n  \n  tally.connections <- function(partners) {\n    paired.events <-\n      selected.interactions[selected.interactions$Primary.Participant.Emlo_ID == partners[[1]] &\n                              selected.interactions$Secondary.Participant.Emlo_ID == partners[[2]],]\n    tally.event.type <-\n      data.frame(data = factor(\n        as.vector(paired.events[,\"Category\"]),\n        levels = levels(selected.interactions$Category)\n      ))\n    tally.event.type <- as.data.frame(table(tally.event.type))\n    totalConnections <- sum(tally.event.type$Freq)\n    # Use dcast to make df wide\n    tally.event.type <-\n      dcast(\n        tally.event.type, formula = . ~ tally.event.type , value.var = \"Freq\", fill = NULL\n      )\n    # Drop the first column which contains useless data\n    tally.event.type[1] <- NULL\n    tally.event.type$Primary.Emlo_ID <- partners[[1]]\n    tally.event.type$Secondary.Emlo_ID <- partners[[2]]\n    tally.event.type$Total.Connections <- totalConnections\n    tally.event.type\n  }\n  \n  invisible(lapply(unique_Connections, function(x){\n    new.edge <- tally.connections(x)\n    edges.of.network <<- rbind(edges.of.network, new.edge)\n  }))\n  \n  # Remove edges where the secondary emlo id is NA\n  edges.of.network <- edges.of.network[!is.na(edges.of.network$Secondary.Emlo_ID),]\n  \n  # Return edges.of.network to the symbol whole.network_edges.of.network\n  edges.of.network\n}\n\n### ====================================== networkD3 - Whole Network ============================================\n### =================================================================================================================\n\noutput$networkD3_wholeNetwork_show_timeslider_UI <- renderUI({\n  checkboxInput(\"networkD3_wholeNetwork_show_timeslider\", label = \"Remove undated interactions and filter by date?\", value = FALSE)\n})\n\noutput$networkD3_wholeNetwork_time_period_of_interest_UI <- renderUI({\n  \n  if(is.null(input$networkD3_wholeNetwork_show_timeslider)){\n    return()\n  }\n  \n  if (!is.null(input$networkD3_wholeNetwork_show_timeslider)){\n    dates <-\n      c(multiparty.interactions$DateOne.Year,multiparty.interactions$DateTwo.Year)\n    dates <- dates[!is.na(dates)]\n    \n    # Remove an incorrect date\n    dates <- dates[dates > 1000]\n    \n    sliderInput(\n      \"networkD3_wholeNetwork_time_period_of_interest\", \"Time period of interest:\",\n      min = min(dates) - 1,\n      max = max(dates),\n      step = 1,\n      value = c(min(dates), max(dates))\n    )\n  }\n})\n\noutput$networkD3_wholeNetwork_HighlightedCategoryUI <- renderUI({\n  selectInput(\n    'networkD3_wholeNetwork_highlightedCategory', 'Event/Relation Type to highlight', choices = all_event_categories(), selected = \"FamilyRelationships\",  \n    multiple = FALSE\n  )\n})\n\noutput$networkD3_wholeNetwork_ExcludedCategoriesUI <- renderUI({\n  \n  if(is.null(input$networkD3_wholeNetwork_show_timeslider)){\n    return()\n  }\n  \n  selectInput(\n    'networkD3_wholeNetwork_ExcludedCategory', 'Event/Relation Type to exclude', choices = c(\"None\",setdiff(all_event_types(),\n                                                                                                            input$networkD3_wholeNetwork_highlightedCategory)),  \n    multiple = FALSE\n  )\n})\n\noutput$networkD3_wholeNetwork_NumberOfExcluded <- renderUI({\n  \n  selected.interactions <- multiparty.interactions\n#  Test suite \n#   networkD3_wholeNetwork_ExcludedCategory <- \"PeerRelationships\"\n  \n  selected.interactions <- selected.interactions[selected.interactions$Event.or.Relationship.Type != input$networkD3_wholeNetwork_ExcludedCategory,]\n  \n  if(input$networkD3_wholeNetwork_show_timeslider == TRUE){\n  ## Start experiment area\n  \n  \n  ## Filter out rows where DateOne.Year is NA or outside of date range\n  selected.interactions <- selected.interactions[{selected.interactions$DateOne.Year >= input$networkD3_wholeNetwork_time_period_of_interest[1]} %in% TRUE & \n  {selected.interactions$DateOne.Year <= input$networkD3_wholeNetwork_time_period_of_interest[2]} %in% TRUE ,]\n  ## Filter out rows where DateTwo.Year is greater than the max date allowd\n  selected.interactions <- selected.interactions[selected.interactions$DateTwo.Year <= input$networkD3_wholeNetwork_time_period_of_interest[2] |\n                                                   is.na(selected.interactions$DateTwo.Year),]\n  \n  ## End Experiment Area\n  }\n  \n  multiparty.people <- unique(c(multiparty.interactions$Primary.Participant.Emlo_ID,multiparty.interactions$Secondary.Participant.Emlo_ID))\n  \n  selected.people <- unique(c(selected.interactions$Primary.Participant.Emlo_ID, selected.interactions$Secondary.Participant.Emlo_ID))\n  \n  \n  HTML(\n    paste0(\n      \"<p>Included interactions: \",nrow(selected.interactions),\"</p>\",\n      \"<p>Included individuals: \",length(selected.people),\"</p>\",\n      \"<p>Excluded interactions: \",nrow(multiparty.interactions)-nrow(selected.interactions),\"</p>\",\n      \"<p>Excluded individuals: \",length(multiparty.people) - length(selected.people),\"</p>\"\n    )\n  )\n  \n  \n})\n\nnetworkD3_wholeNetwork_nodes <- reactive({\n  ## Set selected.interactions as all multiparty.interactions\n  selected.interactions <- multiparty.interactions\n  \n  ## Drop excluded categoties from multiparty interactions\n  selected.interactions <-\n    selected.interactions[selected.interactions$Event.or.Relationship.Type != input$networkD3_wholeNetwork_ExcludedCategory,]\n  \n  if(input$networkD3_wholeNetwork_show_timeslider == TRUE){\n    ## Start experiment area\n    \n    ## Filter out rows where DateOne.Year is NA or outside of date range\n    selected.interactions <- selected.interactions[{selected.interactions$DateOne.Year >= input$networkD3_wholeNetwork_time_period_of_interest[1]} %in% TRUE & \n    {selected.interactions$DateOne.Year <= input$networkD3_wholeNetwork_time_period_of_interest[2]} %in% TRUE ,]\n    ## Filter out rows where DateTwo.Year is greater than the max date allowd\n    selected.interactions <- selected.interactions[selected.interactions$DateTwo.Year <= input$networkD3_wholeNetwork_time_period_of_interest[2] |\n                                                     is.na(selected.interactions$DateTwo.Year),]\n    \n    ## End Experiment Area\n  }\n  \n  \n  ## Apply network.edges.function to selected.interactions\n  edges <- network.edges.function(selected.interactions)\n  ## Get nodes from edges\n  nodes.of.network <-\n    unique(c(edges$Primary.Emlo_ID,edges$Secondary.Emlo_ID))\n  \n  ## Subset people.df by nodes in edges\n  nodes <- subset(people.df, iperson_id %in% nodes.of.network)\n  \n  networkD3_nodes <- data.frame(\n    \"name\" = 0:(nrow(nodes) - 1),\n    \"group\" = rep(1,nrow(nodes)),\n    \"size\" = rep(1,nrow(nodes)),\n    \"surname\" = nodes$Surname,\n    \"emlo_id\" = nodes$iperson_id\n  )\n  ## Return for use\n  \n  networkD3_nodes\n})\n\nnetworkD3_wholeNetwork_edges <- reactive({\n  ## Set selected.interactions as all multiparty.interactions\n  selected.interactions <- multiparty.interactions\n  \n  ## Drop excluded categoties from multiparty interactions\n  selected.interactions <-\n    selected.interactions[selected.interactions$Event.or.Relationship.Type != input$networkD3_wholeNetwork_ExcludedCategory,]\n  \n  if(input$networkD3_wholeNetwork_show_timeslider == TRUE){\n    ## Start experiment area\n    \n    ## Filter out rows where DateOne.Year is NA or outside of date range\n    selected.interactions <- selected.interactions[{selected.interactions$DateOne.Year >= input$networkD3_wholeNetwork_time_period_of_interest[1]} %in% TRUE & \n    {selected.interactions$DateOne.Year <= input$networkD3_wholeNetwork_time_period_of_interest[2]} %in% TRUE ,]\n    ## Filter out rows where DateTwo.Year is greater than the max date allowd\n    selected.interactions <- selected.interactions[selected.interactions$DateTwo.Year <= input$networkD3_wholeNetwork_time_period_of_interest[2] |\n                                                     is.na(selected.interactions$DateTwo.Year),]\n    \n    ## End Experiment Area\n  }\n  \n  \n  ## Apply network.edges.function to selected.interactions\n  edges <- network.edges.function(selected.interactions)\n  ## Get nodes from edges\n  nodes.of.network <-\n    unique(c(edges$Primary.Emlo_ID,edges$Secondary.Emlo_ID))\n  \n  ## Subset people.df by nodes in edges\n  nodes <- subset(people.df, iperson_id %in% nodes.of.network)\n  \n  networkD3_edges <-\n    data.frame(\n      \"source\" = as.numeric(\n        mapvalues(\n          edges$Primary.Emlo_ID, from = nodes$iperson_id, to = 0:(nrow(nodes) - 1),warn_missing = FALSE\n        )\n      ),\n      \"target\" = as.numeric(\n        mapvalues(\n          edges$Secondary.Emlo_ID, from = nodes$iperson_id, to = 0:(nrow(nodes) -\n                                                                      1),warn_missing = FALSE\n        )\n      ),\n      \"source.emlo.id\" = edges$Primary.Emlo_ID,\n      \n      \"target.emlo.id\" = edges$Secondary.Emlo_ID,\n      \n      \n      ## Times the total number of connections by 10 and add 1 if of the highlighted category type\n      ## Allows for testing off oddness for colour and size for the edge width\n      \"value\" = 20 * edges$Total.Connections + edges[,c(input$networkD3_wholeNetwork_highlightedCategory)],\n      \"LinkColor\" = c(rep(\"lightblue\",100),rep(\"red\",nrow(edges) -\n                                                 100))\n    )\n  ## return for use\n  \n  networkD3_edges\n})\n\noutput$networkD3_wholeNetwork <- renderForceNetwork({\n  ## If not loaded yet, stop\n  \n  if (is.null(input$networkD3_wholeNetwork_highlightedCategory))\n    return()\n  \n    networkD3_wholeNetwork_click_script <- \"d3.select(this).select('circle').transition().duration(750).attr('r', 30);\n      Shiny.onInputChange('current_node_id', d.index + 1)\"\n  \n  networkD3_edges <- networkD3_wholeNetwork_edges()\n  \n  networkD3_nodes <- networkD3_wholeNetwork_nodes()\n  \n  forceNetwork(\n    Links = networkD3_edges, Nodes = networkD3_nodes, Source = \"source\",\n    Target = \"target\", Value = \"value\", NodeID = \"surname\", zoom = TRUE,\n    Group = \"group\",\n    fontSize = 10,\n    # linkColour = rep(\"#bf3eff\",nrow(networkD3_edges)),\n    # linkColour = linkColors.by.highlight,\n    linkColour = JS('function(l) { return l.value % 2 == 0 ? \"#ff6666\" : \"lightblue\" }'),\n    opacityNoHover = TRUE,\n    clickAction = networkD3_wholeNetwork_click_script\n  )\n})\n\noutput$networkD3_wholeNetwork_selected_individual_name <- renderText({\n  \n  nodes <- networkD3_wholeNetwork_nodes()\n  \n  selected.emlo.id <- nodes[input$current_node_id,\"emlo_id\"]\n  \n  people.df[people.df$iperson_id == selected.emlo.id,\"Person.Name\"]\n  \n})\n\noutput$networkD3_whole_network_connected_life_events_columns_to_show_UI <- renderUI(tagList(selectInput(\n  'connected_life_events_Cols', 'Columns to show:',\n  usefulCols_life_events, selected = c(\n    \"Primary.Participant.Name\",\"Secondary.Participant.Name\",\"Event.or.Relationship.Type\"),\n  multiple = TRUE\n),tags$style(\n  type = \"text/css\", \"select#selCategories + .selectize-control{width: 800px}\"\n)))\n\noutput$networkD3_whole_network_selected_node <- DT::renderDataTable({\n  \n  #   if(is.null(input$include_interactions_without_dates)){\n  #     return()\n  #   }\n  \n  ## Set selected.interactions as all multiparty.interactions\n  selected.interactions <- multiparty.interactions\n  \n  ## Drop excluded categoties from multiparty interactions\n  selected.interactions <-\n    selected.interactions[selected.interactions$Event.or.Relationship.Type != input$networkD3_wholeNetwork_ExcludedCategory,]\n  \n  if(input$networkD3_wholeNetwork_show_timeslider == TRUE){\n    ## Start experiment area\n    \n    ## Filter out rows where DateOne.Year is NA or outside of date range\n    selected.interactions <- selected.interactions[{selected.interactions$DateOne.Year >= input$networkD3_wholeNetwork_time_period_of_interest[1]} %in% TRUE & \n    {selected.interactions$DateOne.Year <= input$networkD3_wholeNetwork_time_period_of_interest[2]} %in% TRUE ,]\n    ## Filter out rows where DateTwo.Year is greater than the max date allowd\n    selected.interactions <- selected.interactions[selected.interactions$DateTwo.Year <= input$networkD3_wholeNetwork_time_period_of_interest[2] |\n                                                     is.na(selected.interactions$DateTwo.Year),]\n    \n    ## End Experiment Area\n  }\n  \n  \n  # Drop levels that are empty (as a result of above subsetting)\n  selected.interactions <- droplevels(selected.interactions)\n\n  ## Get selected individual from click\n  nodes <- networkD3_wholeNetwork_nodes()\n  selectedIndividual <- nodes[input$current_node_id,\"emlo_id\"]\n  \n  # Get edges of network\n  edges <- networkD3_wholeNetwork_edges()\n  \n\n  connectedIndividuals <- c(as.character(edges[edges$source.emlo.id == selectedIndividual, \"target.emlo.id\"]),\n                            as.character(edges[edges$target.emlo.id == selectedIndividual, \"source.emlo.id\"]))\n  \n  print(connectedIndividuals)\n  print(paste0(\"selectedIndividual: \",selectedIndividual))\n  \n  # Create an empty data.frame with life.event.columns\n  connected_life_events <- selected.interactions[0,]\n  # Function to extract connected events\n  get.connected.life.events <- function(selectedNode, connectedNode){\n    connections <- rbind(\n      selected.interactions[selected.interactions$Primary.Participant.Emlo_ID == selectedNode & \n                              selected.interactions$Secondary.Participant.Emlo_ID == connectedNode,],\n      selected.interactions[selected.interactions$Primary.Participant.Emlo_ID == connectedNode & \n                              selected.interactions$Secondary.Participant.Emlo_ID == selectedNode,]\n    )\n    connected_life_events <<- rbind(connected_life_events, connections)\n  }\n  # lapply function\n  invisible(lapply(connectedIndividuals, function(x)get.connected.life.events(selectedIndividual, x)))\n  \n  \n  # Drop empty rows:\n  connected_life_events <- connected_life_events[!!rowSums(!is.na(connected_life_events)),]\n  \n  connected_life_events[,input$connected_life_events_Cols, drop = FALSE]\n  \n})\n\n### ====================================== Whole Network: visNetwork =====================================\n### ======================================================================================================\n\n\noutput$visNetwork_wholeNetwork_show_timeslider_UI <- renderUI({\n  checkboxInput(\"visNetwork_wholeNetwork_show_timeslider\", label = \"Remove undated interactions and filter by date?\", value = TRUE)\n})\n\noutput$visNetwork_wholeNetwork_time_period_of_interest_UI <- renderUI({\n  \n  if(is.null(input$visNetwork_wholeNetwork_show_timeslider)){\n    return()\n  }\n  \n  if (input$visNetwork_wholeNetwork_show_timeslider == TRUE) {\n    dates <-\n      c(multiparty.interactions$DateOne.Year,multiparty.interactions$DateTwo.Year)\n    dates <- dates[!is.na(dates)]\n    \n    # Remove an incorrect date\n    dates <- dates[dates > 1000]\n    \n    sliderInput(\n      \"visNetwork_wholeNetwork_time_period_of_interest\", \"Time period of interest:\",\n      min = min(dates) - 1,\n      max = max(dates),\n      step = 1,\n      value = c(min(dates), max(dates))\n    )\n  }\n})\n\noutput$visNetwork_wholeNetwork_HighlightedCategoryUI <- renderUI({\n  selectInput(\n    'visNetwork_wholeNetwork_highlightedCategory', 'Event/Relation Type to highlight', choices = all_event_categories(), selected = \"FamilyRelationships\",  \n    multiple = FALSE\n  )\n})\n\noutput$visNetwork_wholeNetwork_ExcludedCategoriesUI <- renderUI({\n  selectInput(\n    'visNetwork_wholeNetwork_ExcludedCategory', 'Event/Relation Type to exclude', choices = c(\"None\",setdiff(all_event_types(),\n                                                                                                             input$visNetwork_wholeNetwork_highlightedCategory)),  \n    multiple = FALSE\n  )\n})\n\noutput$visNetwork_wholeNetwork_NumberOfExcluded <- renderUI({\n  \n  selected.interactions <- multiparty.interactions\n  #  Test suite \n  #   visNetwork_wholeNetwork_ExcludedCategory <- \"PeerRelationships\"\n  \n  selected.interactions <- selected.interactions[selected.interactions$Event.or.Relationship.Type != input$visNetwork_wholeNetwork_ExcludedCategory,]\n  \n  if(input$visNetwork_wholeNetwork_show_timeslider == TRUE){\n    ## Start experiment area\n    \n    \n    ## Filter out rows where DateOne.Year is NA or outside of date range\n    selected.interactions <- selected.interactions[{selected.interactions$DateOne.Year >= input$visNetwork_wholeNetwork_time_period_of_interest[1]} %in% TRUE & \n    {selected.interactions$DateOne.Year <= input$visNetwork_wholeNetwork_time_period_of_interest[2]} %in% TRUE ,]\n    ## Filter out rows where DateTwo.Year is greater than the max date allowd\n    selected.interactions <- selected.interactions[selected.interactions$DateTwo.Year <= input$visNetwork_wholeNetwork_time_period_of_interest[2] |\n                                                     is.na(selected.interactions$DateTwo.Year),]\n    \n    ## End Experiment Area\n  }\n  \n  multiparty.people <- unique(c(multiparty.interactions$Primary.Participant.Emlo_ID,multiparty.interactions$Secondary.Participant.Emlo_ID))\n  \n  selected.people <- unique(c(selected.interactions$Primary.Participant.Emlo_ID, selected.interactions$Secondary.Participant.Emlo_ID))\n  \n  \n  HTML(\n    paste0(\n      \"<p>Include interactions: \",nrow(selected.interactions),\"</p>\",\n      \"<p>Include individuals: \",length(selected.people),\"</p>\",\n      \"<p>Excluded interactions: \",nrow(multiparty.interactions)-nrow(selected.interactions),\"</p>\",\n      \"<p>Excluded individuals: \",length(multiparty.people) - length(selected.people),\"</p>\"\n    )\n  )\n  \n  \n})\n\n\nvisNetwork_wholeNetwork_nodes <- reactive({\n  ## Set selected.interactions as all multiparty.interactions\n  selected.interactions <- multiparty.interactions\n  \n  ## Drop excluded categoties from multiparty interactions\n  selected.interactions <-\n    selected.interactions[selected.interactions$Event.or.Relationship.Type != input$visNetwork_wholeNetwork_ExcludedCategory,]\n  \n  if(input$visNetwork_wholeNetwork_show_timeslider == TRUE){\n    ## Start experiment area\n    \n    ## Filter out rows where DateOne.Year is NA or outside of date range\n    selected.interactions <- selected.interactions[{selected.interactions$DateOne.Year >= input$visNetwork_wholeNetwork_time_period_of_interest[1]} %in% TRUE & \n    {selected.interactions$DateOne.Year <= input$visNetwork_wholeNetwork_time_period_of_interest[2]} %in% TRUE ,]\n    ## Filter out rows where DateTwo.Year is greater than the max date allowd\n    selected.interactions <- selected.interactions[selected.interactions$DateTwo.Year <= input$visNetwork_wholeNetwork_time_period_of_interest[2] |\n                                                     is.na(selected.interactions$DateTwo.Year),]\n    \n    ## End Experiment Area\n  }\n  \n  \n  ## Apply network.edges.function to selected.interactions\n  edges <- network.edges.function(selected.interactions)\n  ## Get nodes from edges\n  nodes.of.network <-\n    unique(c(edges$Primary.Emlo_ID,edges$Secondary.Emlo_ID))\n  \n  ## Subset people.df by nodes in edges\n  nodes <- subset(people.df, iperson_id %in% nodes.of.network)\n  \n  visNetwork_nodes <- data.frame(\n    \"Person.Name\" = nodes$Person.Name,\n    \"Surname\" = nodes$Surname,\n    \"emlo_id\" = nodes$iperson_id\n  )\n  ## Return for use\n  \n  visNetwork_nodes\n})\n\nvisNetwork_wholeNetwork_edges <- reactive({\n  ## Set selected.interactions as all multiparty.interactions\n  selected.interactions <- multiparty.interactions\n  \n  ## Drop excluded categoties from multiparty interactions\n  selected.interactions <-\n    selected.interactions[selected.interactions$Event.or.Relationship.Type != input$visNetwork_wholeNetwork_ExcludedCategory,]\n  \n  if(input$visNetwork_wholeNetwork_show_timeslider == TRUE){\n    ## Start experiment area\n    \n    ## Filter out rows where DateOne.Year is NA or outside of date range\n    selected.interactions <- selected.interactions[{selected.interactions$DateOne.Year >= input$visNetwork_wholeNetwork_time_period_of_interest[1]} %in% TRUE & \n    {selected.interactions$DateOne.Year <= input$visNetwork_wholeNetwork_time_period_of_interest[2]} %in% TRUE ,]\n    ## Filter out rows where DateTwo.Year is greater than the max date allowd\n    selected.interactions <- selected.interactions[selected.interactions$DateTwo.Year <= input$visNetwork_wholeNetwork_time_period_of_interest[2] |\n                                                     is.na(selected.interactions$DateTwo.Year),]\n    \n    ## End Experiment Area\n  }\n  \n  \n  ## Apply network.edges.function to selected.interactions\n  edges <- network.edges.function(selected.interactions)\n  ## Get nodes from edges\n  nodes.of.network <-\n    unique(c(edges$Primary.Emlo_ID,edges$Secondary.Emlo_ID))\n  \n  ## Subset people.df by nodes in edges\n  nodes <- subset(people.df, iperson_id %in% nodes.of.network)\n  \n  visNetwork_edges <-\n    data.frame(\n      \"source\" = as.numeric(\n        mapvalues(\n          edges$Primary.Emlo_ID, from = nodes$iperson_id, to = 0:(nrow(nodes) - 1),warn_missing = FALSE\n        )\n      ),\n      \"target\" = as.numeric(\n        mapvalues(\n          edges$Secondary.Emlo_ID, from = nodes$iperson_id, to = 0:(nrow(nodes) -\n                                                                      1),warn_missing = FALSE\n        )\n      ),\n      \"source.emlo.id\" = edges$Primary.Emlo_ID,\n      \n      \"target.emlo.id\" = edges$Secondary.Emlo_ID,\n      \n      ## Times the total number of connections by 10 and add 1 if of the highlighted category type\n      ## Allows for testing off oddness for colour and size for the edge width\n      \"Value\" = 20 * edges$Total.Connections + edges[,c(input$visNetwork_wholeNetwork_highlightedCategory)],\n      \n      \"EdgeColor\" = mapvalues(edges[,c(input$visNetwork_wholeNetwork_highlightedCategory)] > 0,c(TRUE,FALSE),c(\"darkblue\",\"#ff6666\")),\n      \n      \"LinkColor\" = c(rep(\"lightblue\",100),rep(\"red\",nrow(edges) - 100))\n    )\n  ## return for use\n  \n  visNetwork_edges\n})\n\noutput$visNetwork_wholeNetwork <- renderVisNetwork({\n  ## If not loaded yet, stop\n  \n  if (is.null(input$visNetwork_wholeNetwork_highlightedCategory))\n    return()\n  \n  visNetwork_edges <- visNetwork_wholeNetwork_edges()\n  \n  visNetwork_nodes <- visNetwork_wholeNetwork_nodes()\n  \n  ## Create df for visNetwork\n  visN_nodes <- data.frame(\"id\" = visNetwork_nodes$emlo_id,\n                           \"title\" = as.character(visNetwork_nodes$Person.Name),\n                           \"label\" = as.character(visNetwork_nodes$Surname)\n                           )\n  \n  visN_edges <- data.frame(\"from\" = visNetwork_edges$source.emlo.id,\n                           \"to\" = visNetwork_edges$target.emlo.id,\n                           \"color\" = visNetwork_edges$EdgeColor,\n                           \"value\" = rescale(visNetwork_edges$Value, to = c(2,10)))\n\n  \n  visNetwork(visN_nodes, visN_edges) %>% visNodes(\n    color = list(\n      background = \"lightblue\", border = \"darkblue\"\n    ),\n    size = 10\n  ) %>%\n    # visEdges(value = round(rescale(visNetwork_edges$Value, to = c(2,10)))) %>%\n    # visEdges(width = 4) %>%\n    visInteraction(tooltipDelay = 0.2, hideEdgesOnDrag = FALSE, dragNodes = FALSE, dragView = TRUE, zoomView = TRUE) %>%\n    visOptions(highlightNearest = TRUE) %>% visLayout(hierarchical = FALSE) %>% \n    visInteraction(navigationButtons = TRUE) %>%\n    visEvents(selectNode = \"function(nodes) {\n              Shiny.onInputChange('current_node_id', nodes);\n              ;}\")\n    # visLayout(hierarchical = input$hierachical_layout_option) %>%\n\n  })\n\noutput$visNetwork_wholeNetwork_current_node_id <- renderPrint({\n  \n  \n  people.df[people.df$iperson_id == input$current_node_id$nodes[[1]], \"Person.Name\"]\n  \n})\n\noutput$visNetwork_wholeNetwork_selected_node_info <- renderUI({\n  \n  if(is.null(input$current_node_id)){\n    return()\n  }\n  \n  selected.person.name <- people.df[people.df$iperson_id == as.numeric(input$current_node_id$nodes[[1]]),\"Person.Name\"]\n  \n  wellPanel(HTML(\n    paste0(\n      \"<h2>\",selected.person.name,\"'s Connections</h2>\",\n      \"<p>The table below shows all life events involving the selected individual, \n      note the controller allows columns to be added and removed easily.</p>\"\n    )))\n  \n  \n})\n\noutput$visNetwork_whole_network_connected_life_events_columns_to_show_UI <- renderUI({tagList(selectInput(\n  'connected_life_events_Cols', 'Columns to show:',\n  usefulCols_life_events, selected = c(\n    \"Primary.Participant.Name\",\"Secondary.Participant.Name\",\"Event.or.Relationship.Type\",\"DateOne.Year\"),\n  multiple = TRUE\n),tags$style(\n  type = \"text/css\", \"select#selCategories + .selectize-control{width: 800px}\"\n))})\n\noutput$visNetwork_whole_network_selected_node <- DT::renderDataTable({\n  \n  #   if(is.null(input$include_interactions_without_dates)){\n  #     return()\n  #   }\n  \n  ## Set selected.interactions as all multiparty.interactions\n  selected.interactions <- multiparty.interactions\n  \n  ## Drop excluded categoties from multiparty interactions\n  selected.interactions <-\n    selected.interactions[selected.interactions$Event.or.Relationship.Type != input$visNetwork_wholeNetwork_ExcludedCategory,]\n  \n  if(!is.null(input$visNetwork_wholeNetwork_show_timeslider)){\n    ## Start experiment area\n    \n    ## Filter out rows where DateOne.Year is NA or outside of date range\n    selected.interactions <- selected.interactions[{selected.interactions$DateOne.Year >= input$visNetwork_wholeNetwork_time_period_of_interest[1]} %in% TRUE & \n    {selected.interactions$DateOne.Year <= input$visNetwork_wholeNetwork_time_period_of_interest[2]} %in% TRUE ,]\n    ## Filter out rows where DateTwo.Year is greater than the max date allowd\n    selected.interactions <- selected.interactions[selected.interactions$DateTwo.Year <= input$visNetwork_wholeNetwork_time_period_of_interest[2] |\n                                                     is.na(selected.interactions$DateTwo.Year),]\n    \n    ## End Experiment Area\n  }\n  \n  \n  # Drop levels that are empty (as a result of above subsetting)\n  selected.interactions <- droplevels(selected.interactions)\n  \n  ## Get selected individual from click\n  nodes <- visNetwork_wholeNetwork_nodes()\n  selectedIndividual <- as.numeric(input$current_node_id$nodes[[1]])\n  \n  # Get edges of network\n  edges <- visNetwork_wholeNetwork_edges()\n  \n  \n  connectedIndividuals <- c(as.character(edges[edges$source.emlo.id == selectedIndividual, \"target.emlo.id\"]),\n                            as.character(edges[edges$target.emlo.id == selectedIndividual, \"source.emlo.id\"]))\n  \n  print(connectedIndividuals)\n  print(paste0(\"selectedIndividual: \",selectedIndividual))\n  \n  # Create an empty data.frame with life.event.columns\n  connected_life_events <- selected.interactions[0,]\n  # Function to extract connected events\n  get.connected.life.events <- function(selectedNode, connectedNode){\n    connections <- rbind(\n      selected.interactions[selected.interactions$Primary.Participant.Emlo_ID == selectedNode & \n                              selected.interactions$Secondary.Participant.Emlo_ID == connectedNode,],\n      selected.interactions[selected.interactions$Primary.Participant.Emlo_ID == connectedNode & \n                              selected.interactions$Secondary.Participant.Emlo_ID == selectedNode,]\n    )\n    connected_life_events <<- rbind(connected_life_events, connections)\n  }\n  # lapply function\n  invisible(lapply(connectedIndividuals, function(x)get.connected.life.events(selectedIndividual, x)))\n  \n  \n  # Drop empty rows:\n  connected_life_events <- connected_life_events[!!rowSums(!is.na(connected_life_events)),]\n  \n  connected_life_events[,input$connected_life_events_Cols, drop = FALSE]\n  \n})\n\n# ### ====================================== OLD === Whole Network Page: visNetwork ===OLD =========================================\n# ### =================================================================================================================\n# \n# output$event_category_selection_UI <- renderUI({\n#   selectInput(\n#     'selected_event_categories', 'Event Categories to include', all_event_categories(), selected = all_event_categories(),  \n#     multiple = TRUE\n#   )\n# })\n# \n# output$event_type_selection_UI <- renderUI({\n#   selectInput(\n#     'selected_event_types', 'Event/Relation Types to include', all_event_types(), selected = all_event_types(),  \n#     multiple = TRUE\n#   )\n# })\n# \n# \n# \n# whole.network_edges <- reactive({\n#   \n#   #   if(is.null(input$include_interactions_without_dates)){\n#   #     return()\n#   #   }\n#   \n#   ## Set selected.interactions as all multiparty.interactions\n#   selected.interactions <- multiparty.interactions\n#   \n#   #   ## Drop interactions according to date options\n#   #   selected.interactions <- if(input$include_interactions_without_dates){\n#   #     selected.interactions\n#   #   } else {\n#   #     selected.interactions[!is.na(selected.interactions$DateOne.Year) & !is.na(selected.interactions$DateTwo.Year),]\n#   #   }\n#   \n#   ## Drop excluded categoties from multiparty interactions\n#   selected.interactions <- subset(\n#     selected.interactions,Category %in% input$selected_event_categories &\n#       Event.or.Relationship.Type %in% input$selected_event_types\n#   )\n#   \n#   # Drop levels that are empty (as a result of above subsetting)\n#   selected.interactions <- droplevels(selected.interactions)\n#   \n#   edges <- network.edges.function(selected.interactions)\n#   \n#   edges\n# })\n# \n# \n# output$whole.network_visNetwork <- renderVisNetwork({\n#   \n#   ## If not loaded yet, stop\n#   \n#   if (is.null(input$hierachical_layout_option))\n#     return()\n#   \n#   ## Get edges from whole.network.edges()\n#   edges <- whole.network_edges()\n#   ## Get nodes from edges\n#   nodes.of.network <- unique(c(edges$Primary.Emlo_ID,edges$Secondary.Emlo_ID))\n#   ## Subset people.df by nodes in edges\n#   nodes <- subset(people.df, iperson_id %in% nodes.of.network)\n#   \n#   \n#   ## Make igraph\n#   edges_igraph <- edges[,c(\"Primary.Emlo_ID\",\"Secondary.Emlo_ID\")]\n#   nodes_igraph <- nodes$iperson_id\n#   ## generate igraph\n#   whole.network_igraph <- graph.data.frame(edges_igraph, nodes_igraph, directed = FALSE)\n#   ## plot igraph\n#   plot(whole.network_igraph,vertex.size=2, edge.arrow.size=.2)\n#   ecount(whole.network_igraph)\n#   \n#   \n#   ## Create df for visNetwork\n#   visN_nodes <- data.frame(\"id\" = nodes$iperson_id,\n#                            \"title\" = nodes$Person.Name)\n#   \n#   visN_edges <- data.frame(\"from\" = edges$Primary.Emlo_ID,\n#                            \"to\" = edges$Secondary.Emlo_ID)\n#   \n#   visNetwork(visN_nodes, visN_edges) %>% visNodes(\n#     color = list(\n#       background = \"lightblue\", border = \"darkblue\"\n#     ),\n#     size = 10\n#   ) %>%\n#     visInteraction(tooltipDelay = 0.2, hideEdgesOnDrag = TRUE, dragNodes = FALSE, dragView = FALSE, zoomView = FALSE) %>%\n#     visOptions(highlightNearest = TRUE) %>%\n#     visLayout(hierarchical = input$hierachical_layout_option) %>%\n#     visEvents(selectNode = \"function(nodes) {\n#           Shiny.onInputChange('current_node_id', nodes);\n#               ;}\")\n# })\n# \n# ### ========= UI for controlling what data is shown for individuals connected to the selected node\n# \n# \n# \n# ### ======== Display selected.interactions for the selected node in the network\n# \n# output$selected.individual.name <- renderText({\n#   selectedIndividual <- input$current_node_id$nodes[[1]]\n#   selectedIndividual <- people.df[people.df$iperson_id == selectedIndividual,]\n#   as.character(selectedIndividual$Person.Name)\n# })\n# \n# output$connected_life_events_columns_to_show_UI <- renderUI(tagList(selectInput(\n#   'connected_life_events_Cols', 'Columns to show:',\n#   usefulCols_life_events, selected = c(\n#     \"Primary.Participant.Name\",\"Secondary.Participant.Name\",\"Event.or.Relationship.Type\"),\n#   multiple = TRUE\n# ),tags$style(\n#   type = \"text/css\", \"select#selCategories + .selectize-control{width: 800px}\"\n# )))\n# \n# output$selected_node <- DT::renderDataTable({\n#   \n# #   if(is.null(input$include_interactions_without_dates)){\n# #     return()\n# #   }\n#   \n#   ## Set selected.interactions as all multiparty.interactions\n#   \n#   selected.interactions <- multiparty.interactions\n#   \n# #   ## Drop interactions according to date options\n# #   \n# #   selected.interactions <- if(input$include_interactions_without_dates){\n# #     selected.interactions\n# #   } else {\n# #     selected.interactions[!is.na(selected.interactions$DateOne.Year) & !is.na(selected.interactions$DateTwo.Year),]\n# #   }\n#   \n#   ## Drop excluded categoties from multiparty interactions\n#   selected.interactions <- subset(\n#     selected.interactions,Category %in% input$selected_event_categories &\n#       Event.or.Relationship.Type %in% input$selected_event_types\n#   )\n#   \n#   # Drop levels that are empty (as a result of above subsetting)\n#   selected.interactions <- droplevels(selected.interactions)\n#   \n#   selectedIndividual <- input$current_node_id$nodes[[1]]\n#   \n#   # selectedIndividual <- 21584\n#   \n#   edges <- whole.network_edges()\n#   \n#   connectedIndividuals <- c(edges[edges$Primary.Emlo_ID == selectedIndividual, \"Secondary.Emlo_ID\"],\n#                             edges[edges$Secondary.Emlo_ID == selectedIndividual, \"Primary.Emlo_ID\"])\n# \n#   # Create an empty data.frame with life.event.columns\n#   connected_life_events <- selected.interactions[0,]\n#   # Function to extract connected events\n#   get.connected.life.events <- function(selectedNode, connectedNode){\n#     connections <- rbind(\n#       selected.interactions[selected.interactions$Primary.Participant.Emlo_ID == selectedNode & \n#                               selected.interactions$Secondary.Participant.Emlo_ID == connectedNode,],\n#       selected.interactions[selected.interactions$Primary.Participant.Emlo_ID == connectedNode & \n#                               selected.interactions$Secondary.Participant.Emlo_ID == selectedNode,]\n#     )\n#     connected_life_events <<- rbind(connected_life_events, connections)\n#   }\n#   # lapply function\n#   invisible(lapply(connectedIndividuals, function(x)get.connected.life.events(selectedIndividual, x)))\n#   \n#   \n#   # Drop empty rows:\n#   connected_life_events <- connected_life_events[!!rowSums(!is.na(connected_life_events)),]\n# \n#   connected_life_events[,input$connected_life_events_Cols, drop = FALSE]\n#   \n#   })\n\n### ====================================== Selected Two Individuals Prosopography ============================================\n### =================================================================================================================\n\n\noutput$select.individual.1_UI <- renderUI({\n  \n  ## Only include people who are in the multiparty events!\n  \n  people.with.connections <- unique(c(multiparty.interactions$Primary.Participant.Emlo_ID,multiparty.interactions$Secondary.Participant.Emlo_ID))\n  \n  people.with.connections <- subset(people.df, iperson_id %in% people.with.connections)\n  \n  labels.list <- as.character(people.with.connections$Person.Name)\n  values.list <- as.list(unlist(as.character(people.with.connections$iperson_id)))\n  \n  names(values.list) <- labels.list\n  \n  selectInput(\"select.individual.1\", label = \"Select individual for prosopography analysis\",\n              choices = values.list, selected = \"908078\", multiple = FALSE)\n  })\n\n## Select second individual\noutput$select.individual.2_UI <- renderUI({\n  \n  people.with.connections <- unique(c(multiparty.interactions$Primary.Participant.Emlo_ID,multiparty.interactions$Secondary.Participant.Emlo_ID))\n  \n  people.with.connections <- subset(people.df, iperson_id %in% people.with.connections)\n  \n  labels.list <- as.character(people.with.connections$Person.Name)\n  values.list <- as.list(unlist(as.character(people.with.connections$iperson_id)))\n  \n  names(values.list) <- labels.list\n  \n  values.list <- values.list[!labels.list == input$select.individual.1]\n  \n  selectInput(\"select.individual.2\", label = \"Select individual for prosopography analysis\",\n              choices = values.list, selected = \"300007\", multiple = FALSE)})\n\noutput$neighbor.degree.UI <- renderUI({\n  sliderInput(\"neighbor.degree\", label = \"Neighbor Degree\", min = 1, max = 5, value = 2, step = 1)\n})\n\n\nselect.individual.edges <- reactive({\n\n  if (is.null(input$select.individual.2))\n    return()\n  \n   \n  selected.individual.1 <- input$select.individual.1\n  selected.individual.2 <- input$select.individual.2\n  \n  ## Generate edges\n  edges <- network.edges.function(multiparty.interactions)\n  ## Get just edges for igraph\n  edges <- edges[,c(\"Primary.Emlo_ID\",\"Secondary.Emlo_ID\")]\n  ## Extract nodes\n  nodes <- unique(c(edges$Primary.Emlo_ID,edges$Secondary.Emlo_ID))\n  ## Generate igraph\n  igraph.for.computation <- graph.data.frame(edges, nodes, directed = FALSE)\n  ## plot igraph\n  # plot(igraph.for.computation, vertex.size=2, vertex.label=NA, edge.arrow.size=.2)\n  \n  ## test suite\n  neighboring_nodes <- graph.union(make_ego_graph(igraph.for.computation, order = 1, nodes = c(selected.individual.1, selected.individual.2)))\n  \n  ## Find neihbouring nodes, graph.union is needed as make_ego_graph outputs a list of graph\n  neighboring_nodes <- graph.union(make_ego_graph(igraph.for.computation, order = input$neighbor.degree, nodes = c(selected.individual.1, selected.individual.2)))\n  # plot igraph of neighboring vertices\n  # plot(neighboring_nodes,vertex.size=2, vertex.label=V(neighboring_nodes)$name, edge.arrow.size=.2)\n  \n  ## Subset multiparty.interactions by the node names:\n  selected.interactions <- subset(multiparty.interactions, Primary.Participant.Emlo_ID %in% V(neighboring_nodes)$name &\n                                    Secondary.Participant.Emlo_ID %in% V(neighboring_nodes)$name)\n  \n  ## Generates edges for visNetwork\n  \n  visN_edges <- network.edges.function(selected.interactions)\n  \n  ## Return dataframe\n  visN_edges\n})\n\n\n## Show connections between selected individuals\noutput$select.individual.network_graph <- renderVisNetwork({\n  \n  ## If not loaded yet, stop\n  \n  if (is.null(input$select.individual.2))\n    return()\n  \n  ## load visN_edges\n  \n  visN_edges <- select.individual.edges()\n  \n  visN_edges <- data.frame(\"from\" = visN_edges$Primary.Emlo_ID,\n                           \"to\" = visN_edges$Secondary.Emlo_ID,stringsAsFactors = FALSE)\n\n  \n  ## Subset people.df by the nodes appearing in the edges:\n  \n  visN_nodes <- subset(people.df, iperson_id %in% unique(c(visN_edges$from,visN_edges$to)))\n  \n  ## Pull out data for visNetwork\n  \n  visN_nodes <- data.frame(\"id\" = visN_nodes$iperson_id,\n                           \"title\" = visN_nodes$Person.Name,\n                           \"label\" = visN_nodes$Surname)\n  \n  ## Highlight the selected nodes as red\n  \n  node_colors <- rep(\"lightblue\",nrow(visN_nodes))\n  node_colors[match(c(input$select.individual.1,input$select.individual.2), visN_nodes$id)] <- \"red\"\n  \n  visN_nodes$color <- node_colors\n  \n  ## Visualise\n  \n  visNetwork(visN_nodes, visN_edges) %>% visNodes(\n    color = list(\n      border = \"darkblue\"\n    )\n  ) %>%\n    visInteraction(tooltipDelay = 0.2, hideEdgesOnDrag = TRUE, dragNodes = FALSE, dragView = FALSE, zoomView = TRUE) %>%\n    visOptions(highlightNearest = TRUE) %>%\n    visLayout(hierarchical = FALSE) %>% visInteraction(navigationButtons = TRUE) %>%\n    visEvents(selectNode = \"function(nodes) {\n                Shiny.onInputChange('current_node_id', nodes);\n                ;}\")\n    \n  \n})\n\n\n### ====================================== Selected Individuals Prosopography ============================================\n### =================================================================================================================\n\n\noutput$select.individual_personInfo <- renderTable({\n  selected.individual <- input$select.individual\n  people.df[people.df$Person.Name == selected.individual,]\n  })\n\noutput$select.individual_personInfo <- renderTable({\n  selected.individual <- input$select.individual\n  people.df[people.df$Person.Name == selected.individual,]\n})\n\n\nselect.individual_edges <- reactive({\n  \n  selected.interactions <- subset(\n    all.documented.interactions, Primary.Participant.Name %in% input$select.individual |\n      Secondary.Participant.Name %in% input$select.individual\n  )\n  \n  # Drop levels that are empty (as a result of above subsetting)\n  selected.interactions <- droplevels(selected.interactions)\n  \n  edges <- network.edges.function(selected.interactions)\n  \n  edges\n})\n\noutput$select.individual_UI <- renderUI(selectInput(\"select.individual\", label = \"Select individual for prosopography analysis\",\n                                                    choices = unique(c(as.character(all.documented.interactions$Primary.Participant.Name),\n                                                                       as.character(all.documented.interactions$Secondary.Participant.Name))\n                                                    )))\n\noutput$select.individual_visNetwork <- renderVisNetwork({\n  \n  \n  edges <- select.individual_edges()\n  \n  nodes.of.network <- unique(c(edges$Primary.Emlo_ID,edges$Secondary.Emlo_ID))\n  \n  nodes <- subset(people.df, iperson_id %in% nodes.of.network)\n  \n  visN_nodes <- data.frame(\"id\" = nodes$iperson_id,\n                           \"title\" = nodes$Person.Name)\n  \n  visN_edges <- data.frame(\"from\" = edges$Primary.Emlo_ID,\n                           \"to\" = edges$Secondary.Emlo_ID)\n  \n  visNetwork(visN_nodes, visN_edges) %>% visNodes(\n    color = list(\n      background = \"lightblue\", border = \"darkblue\"\n    )\n  ) %>%\n    visLayout(hierarchical = input$hierachical_layout_option) %>%\n    visInteraction(tooltipDelay = 0.2, hideEdgesOnDrag = TRUE, dragNodes = FALSE, dragView = FALSE, zoomView = FALSE) %>%\n    visOptions(highlightNearest = TRUE)\n  })\n\n",
    "created" : 1453372809177.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2077066459",
    "id" : "171C5E37",
    "lastKnownWriteTime" : 1453373719,
    "path" : "~/Github/EMLO-Visualisations/shinyapp/server/visualisations-and-ui.R",
    "project_path" : "shinyapp/server/visualisations-and-ui.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}