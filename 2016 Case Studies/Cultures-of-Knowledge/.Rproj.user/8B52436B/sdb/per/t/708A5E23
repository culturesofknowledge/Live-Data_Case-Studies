{
    "contents" : "## =============================== License ========================================\n## ================================================================================\n## This work is distributed under the MIT license, included in the parent directory\n## Copyright Owner: University of Oxford\n## Date of Authorship: 2016\n## Author: Martin John Hadley (orcid.org/0000-0002-3039-6849)\n## Academic Contact: Arno Bosse (http://orcid.org/0000-0003-3681-1289)\n## Data Source: emlo.bodleian.ox.ac.uk\n## ================================================================================\n\n\n### ============= Useful Visualisations Tools ========================= ###\n\n## ggplot Color Function from http://stackoverflow.com/a/8197703/1659890\ngg_color_hue <- function(n) {\n  hues = seq(15, 375, length = n + 1)\n  hcl(h = hues, l = 65, c = 100)[1:n]\n}\n\n### ====================================== Whole Network Page: UI ============================================\n### =================================================================================================================\n\nusefulCols_life_events <- c(\"Primary.Participant.Name\",\"Secondary.Participant.Name\",\"Event.or.Relationship.Type\",\n                            \"Category\",\"DateOne.Year\", \"DateOne.Month\", \"DateOne.Day\",\"DateOne.Uncertainty\",\"DateTwo.Year\",                 \n                            \"DateTwo.Month\", \"DateTwo.Day\",\"DateTwo.Uncertainty\",\"Date.Type\",\"Location.Details\",\"Location.Region\",\n                            \"Location.Country\",\"Textual.Source.Source\")\n\n### ========= show/hide advanced options for the whole network\n\n# shinyjs::onclick(\"toggleDateOptions\",\n#                  shinyjs::toggle(id = \"dateOptions\", anim = TRUE)) \n\n# shinyjs::onclick(\"toggleAdditionalOptions\",\n#                  shinyjs::toggle(id = \"additionalOptions\", anim = TRUE)) \n\n### ========= Exclude entries without a date\n\n# output$include_interactions_without_dates_UI <- renderUI({\n#   checkboxInput(inputId = \"include_interactions_without_dates\", label = \"Include interactions without dates?\", value = FALSE)\n# })\n\n### ========= Category/Type Selection UI Elements\n\nall_event_types <- reactive(levels(multiparty.interactions$Event.or.Relationship.Type))\nall_event_categories <- reactive(levels(multiparty.interactions$Category))\n\n### ====================================== Generate Edges Function ============================================\n### =================================================================================================================\n\nnetwork.edges.function <- function(selected.interactions){\n  \n  edges.of.network <- data.frame(\"Primary.Emlo_ID\" = character(),\n                                 \"Secondary.Emlo_ID\" = character(),\n                                 \"EcclesiasticalActivities\" = character(),\n                                 \"EducationalActivities\" = numeric(),\n                                 \"FamilyRelationships\" = numeric(),\n                                 \"HierarchicalRelationships\" = numeric(),\n                                 \"LearnedActivities\" = numeric(),\n                                 \"MajorLifeEvents\"= numeric(),\n                                 \"PeerRelationships\" = numeric(),\n                                 \"PoliticalActivities\" = numeric(),\n                                 \"ProfessionalActivities\" = numeric(),\n                                 \"SocialStatusChange\" = numeric()\n  )\n  # Find unique connections (relying on EMLO_ID)\n  unique_Connections <- unique(selected.interactions[,c(\"Primary.Participant.Emlo_ID\",\"Secondary.Participant.Emlo_ID\")])\n  # Split into a list for easier usage in lapply operations later!\n  unique_Connections <- split(unique_Connections, seq(nrow(unique_Connections)))\n\n  \n  tally.connections <- function(partners) {\n    paired.events <-\n      selected.interactions[selected.interactions$Primary.Participant.Emlo_ID == partners[[1]] &\n                              selected.interactions$Secondary.Participant.Emlo_ID == partners[[2]],]\n    tally.event.type <-\n      data.frame(data = factor(\n        as.vector(paired.events[,\"Category\"]),\n        levels = levels(selected.interactions$Category)\n      ))\n    tally.event.type <- as.data.frame(table(tally.event.type))\n    totalConnections <- sum(tally.event.type$Freq)\n    # Use dcast to make df wide\n    tally.event.type <-\n      dcast(\n        tally.event.type, formula = . ~ tally.event.type , value.var = \"Freq\", fill = NULL\n      )\n    # Drop the first column which contains useless data\n    tally.event.type[1] <- NULL\n    tally.event.type$Primary.Emlo_ID <- partners[[1]]\n    tally.event.type$Secondary.Emlo_ID <- partners[[2]]\n    tally.event.type$Total.Connections <- totalConnections\n    tally.event.type\n  }\n  \n  invisible(lapply(unique_Connections, function(x){\n    new.edge <- tally.connections(x)\n    edges.of.network <<- rbind(edges.of.network, new.edge)\n  }))\n  \n  # Remove edges where the secondary emlo id is NA\n  edges.of.network <- edges.of.network[!is.na(edges.of.network$Secondary.Emlo_ID),]\n  \n  # Return edges.of.network to the symbol whole.network_edges.of.network\n  edges.of.network\n}\n\n### ====================================== Whole Network: visNetwork =====================================\n### ======================================================================================================\n\n\noutput$visNetwork_wholeNetwork_show_timeslider_UI <- renderUI({\n  checkboxInput(\"visNetwork_wholeNetwork_show_timeslider\", label = \"Remove undated interactions and filter by date?\", value = TRUE)\n})\n\noutput$visNetwork_wholeNetwork_time_period_of_interest_UI <- renderUI({\n  \n  if(is.null(input$visNetwork_wholeNetwork_show_timeslider)){\n    return()\n  }\n  \n  if (input$visNetwork_wholeNetwork_show_timeslider == TRUE) {\n    dates <-\n      c(multiparty.interactions$DateOne.Year,multiparty.interactions$DateTwo.Year)\n    dates <- dates[!is.na(dates)]\n    \n    # Remove an incorrect date\n    dates <- dates[dates > 1000]\n    \n    sliderInput(\n      \"visNetwork_wholeNetwork_time_period_of_interest\", \"Time period of interest:\",\n      min = min(dates) - 1,\n      max = max(dates),\n      step = 1,\n      value = c(min(dates), max(dates))\n    )\n  }\n})\n\noutput$visNetwork_wholeNetwork_HighlightedCategoryUI <- renderUI({\n  selectInput(\n    'visNetwork_wholeNetwork_highlightedCategory', 'Event/Relation Type to highlight', choices = all_event_categories(), selected = \"FamilyRelationships\",  \n    multiple = FALSE\n  )\n})\n\noutput$visNetwork_wholeNetwork_ExcludedCategoriesUI <- renderUI({\n  selectInput(\n    'visNetwork_wholeNetwork_ExcludedCategory', 'Event/Relation Type to exclude', choices = c(\"None\",setdiff(all_event_types(),\n                                                                                                             input$visNetwork_wholeNetwork_highlightedCategory)),  \n    multiple = FALSE\n  )\n})\n\noutput$visNetwork_wholeNetwork_NumberOfExcluded <- renderUI({\n  \n  selected.interactions <- multiparty.interactions\n  #  Test suite \n  #   visNetwork_wholeNetwork_ExcludedCategory <- \"PeerRelationships\"\n  \n  ## Drop excluded categoties from multiparty interactions\n  selected.interactions <-\n    selected.interactions[selected.interactions$Event.or.Relationship.Type != input$visNetwork_wholeNetwork_ExcludedCategory,]\n  \n  if(input$visNetwork_wholeNetwork_show_timeslider == TRUE){\n    \n    ## Filter out rows where DateOne.Year is NA or outside of date range\n    selected.interactions <- selected.interactions[{selected.interactions$DateOne.Year >= input$visNetwork_wholeNetwork_time_period_of_interest[1]} %in% TRUE & \n    {selected.interactions$DateOne.Year <= input$visNetwork_wholeNetwork_time_period_of_interest[2]} %in% TRUE ,]\n    ## Filter out rows where DateTwo.Year is greater than the max date allowd\n    selected.interactions <- selected.interactions[selected.interactions$DateTwo.Year <= input$visNetwork_wholeNetwork_time_period_of_interest[2] |\n                                                     is.na(selected.interactions$DateTwo.Year),]\n    \n  }\n  \n  multiparty.people <- unique(c(multiparty.interactions$Primary.Participant.Emlo_ID,multiparty.interactions$Secondary.Participant.Emlo_ID))\n  \n  selected.people <- unique(c(selected.interactions$Primary.Participant.Emlo_ID, selected.interactions$Secondary.Participant.Emlo_ID))\n  \n  HTML(\n    paste0(\n      \"<p>Included interactions: \",nrow(selected.interactions),\"</p>\",\n      \"<p>Included individuals: \",length(selected.people),\"</p>\",\n      \"<p>Excluded interactions: \",nrow(multiparty.interactions)-nrow(selected.interactions),\"</p>\",\n      \"<p>Excluded individuals: \",length(multiparty.people) - length(selected.people),\"</p>\"\n    )\n  )\n  \n  \n})\n\n\nvisNetwork_wholeNetwork_nodes <- reactive({\n  ## Set selected.interactions as all multiparty.interactions\n  selected.interactions <- multiparty.interactions\n  \n  ## Drop excluded categoties from multiparty interactions\n  selected.interactions <-\n    selected.interactions[selected.interactions$Event.or.Relationship.Type != input$visNetwork_wholeNetwork_ExcludedCategory,]\n  \n  if(input$visNetwork_wholeNetwork_show_timeslider == TRUE){\n    ## Start experiment area\n    \n    ## Filter out rows where DateOne.Year is NA or outside of date range\n    selected.interactions <- selected.interactions[{selected.interactions$DateOne.Year >= input$visNetwork_wholeNetwork_time_period_of_interest[1]} %in% TRUE & \n    {selected.interactions$DateOne.Year <= input$visNetwork_wholeNetwork_time_period_of_interest[2]} %in% TRUE ,]\n    ## Filter out rows where DateTwo.Year is greater than the max date allowd\n    selected.interactions <- selected.interactions[selected.interactions$DateTwo.Year <= input$visNetwork_wholeNetwork_time_period_of_interest[2] |\n                                                     is.na(selected.interactions$DateTwo.Year),]\n    \n    ## End Experiment Area\n  }\n  \n  \n  ## Apply network.edges.function to selected.interactions\n  edges <- network.edges.function(selected.interactions)\n  ## Get nodes from edges\n  nodes.of.network <-\n    unique(c(edges$Primary.Emlo_ID,edges$Secondary.Emlo_ID))\n  \n  ### ==== Start Experiment\n  \n  test_nodes_in_people.df <- subset(people.df, iperson_id %in% nodes.of.network)$iperson_id\n  test_nodes_not_in_people.df <- setdiff(nodes.of.network, test_nodes_in_people.df)\n  \n  ### ==== End Experiment\n  \n  ## Only include individuals in the people.df data set\n  nodes <- subset(people.df, iperson_id %in% nodes.of.network)\n  \n  visNetwork_nodes <- data.frame(\n    \"Person.Name\" = nodes$Person.Name,\n    \"Surname\" = nodes$Surname,\n    \"emlo_id\" = nodes$iperson_id,\n    \"color\" = rep(\"lightblue\", nrow(nodes))\n  )\n  ## Return for use\n  \n  visNetwork_nodes\n})\n\nvisNetwork_wholeNetwork_edges <- reactive({\n  ## Set selected.interactions as all multiparty.interactions\n  selected.interactions <- multiparty.interactions\n  \n  ## Drop excluded categoties from multiparty interactions\n  selected.interactions <-\n    selected.interactions[selected.interactions$Event.or.Relationship.Type != input$visNetwork_wholeNetwork_ExcludedCategory,]\n  \n  if(input$visNetwork_wholeNetwork_show_timeslider == TRUE){\n    \n    ## Filter out rows where DateOne.Year is NA or outside of date range\n    selected.interactions <- selected.interactions[{selected.interactions$DateOne.Year >= input$visNetwork_wholeNetwork_time_period_of_interest[1]} %in% TRUE & \n    {selected.interactions$DateOne.Year <= input$visNetwork_wholeNetwork_time_period_of_interest[2]} %in% TRUE ,]\n    ## Filter out rows where DateTwo.Year is greater than the max date allowd\n    selected.interactions <- selected.interactions[selected.interactions$DateTwo.Year <= input$visNetwork_wholeNetwork_time_period_of_interest[2] |\n                                                     is.na(selected.interactions$DateTwo.Year),]\n  }\n  \n  \n  ## Apply network.edges.function to selected.interactions\n  edges <- network.edges.function(selected.interactions)\n  ## Get nodes from edges\n  nodes.of.network <-\n    unique(c(edges$Primary.Emlo_ID,edges$Secondary.Emlo_ID))\n  \n  ## Subset people.df by nodes in edges\n  nodes <- subset(people.df, iperson_id %in% nodes.of.network)\n  \n  visNetwork_edges <-\n    data.frame(\n      \"source\" = as.numeric(\n        mapvalues(\n          edges$Primary.Emlo_ID, from = nodes$iperson_id, to = 0:(nrow(nodes) - 1),warn_missing = FALSE\n        )\n      ),\n      \"target\" = as.numeric(\n        mapvalues(\n          edges$Secondary.Emlo_ID, from = nodes$iperson_id, to = 0:(nrow(nodes)-1),warn_missing = FALSE\n        )\n      ),\n      \"source.emlo.id\" = as.numeric(edges$Primary.Emlo_ID),\n      \"target.emlo.id\" = as.numeric(edges$Secondary.Emlo_ID),\n      ## Times the total number of connections by 10 and add 1 if of the highlighted category type\n      ## Allows for testing off oddness for colour and size for the edge width\n      \"Value\" = 20 * edges$Total.Connections + edges[,c(input$visNetwork_wholeNetwork_highlightedCategory)],\n      \"EdgeColor\" = mapvalues(edges[,c(input$visNetwork_wholeNetwork_highlightedCategory)] > 0,c(TRUE,FALSE),c(\"#ff6666\",\"lightblue\"))\n    )\n  \n  ## return for use\n  \n  visNetwork_edges\n})\n\noutput$visNetwork_wholeNetwork_highlighted_node_UI <- renderUI({\n  ## If not loaded yet, stop\n  if (is.null(input$visNetwork_wholeNetwork_highlightedCategory)){\n    return()\n  }\n  \n  visNetwork_nodes <- visNetwork_wholeNetwork_nodes()\n  \n  labels.list <- as.character(visNetwork_nodes$Person.Name)\n  values.list <- as.list(unlist(as.character(visNetwork_nodes$emlo_id)))\n  \n  names(values.list) <- labels.list\n  \n  selectInput(\"highlighted.node\", label = \"Highlight node\",\n              choices = values.list, selected = as.character(values.list[1]), multiple = FALSE)\n  \n  \n  }\n)\n\noutput$visNetwork_wholeNetwork <- renderVisNetwork({\n  ## If not loaded yet, stop\n  \n  if (is.null(input$visNetwork_wholeNetwork_highlightedCategory))\n    return()\n  \n  visNetwork_edges <- visNetwork_wholeNetwork_edges()\n  visNetwork_nodes <- visNetwork_wholeNetwork_nodes()\n  \n  ## Create df for visNetwork\n  visN_nodes <- data.frame(\"id\" = visNetwork_nodes$emlo_id,\n                           \"title\" = as.character(visNetwork_nodes$Person.Name),\n                           \"label\" = as.character(visNetwork_nodes$Surname),\n                           \"color\" = as.character(visNetwork_nodes$color)\n                           )\n  \n  visN_nodes$color <- as.character(visN_nodes$color)\n  \n  visN_edges <- data.frame(\"from\" = visNetwork_edges$source.emlo.id,\n                           \"to\" = visNetwork_edges$target.emlo.id,\n                           \"color\" = visNetwork_edges$EdgeColor,\n                           \"value\" = rescale(visNetwork_edges$Value, to = c(2,10)))\n\n  ## Drop duplicate node:\n  visN_nodes <- visN_nodes[!duplicated(visN_nodes$id),]\n  \n  visN_nodes[visN_nodes$id == input$highlighted.node,]$color <- \"red\"\n  \n  print(visN_nodes$color)\n  \n  ## Make background colour vector\n  node.background.color <- rep(\"lightblue\",nrow(visN_nodes))\n  ## Set highlighted.node to be red\n  node.background.color[visN_nodes$id == input$highlighted.node] <- \"red\"\n  \n  ## Drop edges with nodes not in the node list\n  non.conflicting.nodes <- intersect(unique(c(visN_edges$from, visN_edges$to)), visN_nodes$id)\n  visN_edges <- subset(visN_edges, from %in% non.conflicting.nodes & to %in% non.conflicting.nodes)\n  \n  ## Make network\n  visNetwork(visN_nodes, visN_edges) %>% \n    visNodes(color = list(border = \"darkblue\"), size = 10) %>%\n    visIgraphLayout() %>%\n    # visEdges(value = round(rescale(visNetwork_edges$Value, to = c(2,10)))) %>%\n    # visEdges(width = 4) %>%\n    visInteraction(tooltipDelay = 0.2, hideEdgesOnDrag = FALSE, dragNodes = FALSE, dragView = TRUE, zoomView = TRUE) %>%\n    visOptions(highlightNearest = TRUE) %>% visLayout(hierarchical = FALSE) %>% \n    visInteraction(navigationButtons = TRUE) %>%\n    visEvents(selectNode = \"function(nodes) {\n              Shiny.onInputChange('current_node_id', nodes);\n              ;}\")\n\n  })\n\noutput$visNetwork_wholeNetwork_selected_node_info <- renderUI({\n  \n  if(is.null(input$current_node_id)){\n    return()\n  }\n  \n  selected.person.name <- people.df[people.df$iperson_id == as.numeric(input$current_node_id$nodes[[1]]),\"Person.Name\"]\n  selected.person.name <- selected.person.name[!is.na(selected.person.name)]\n  \n  wellPanel(HTML(\n    paste0(\n      \"<h2>\",selected.person.name,\"'s Connections</h2>\",\n      \"<p>The table below shows all life events involving the selected individual, \n      note the controller allows columns to be added and removed easily.</p>\", sep=\"\"\n    )))\n  \n  \n})\n\noutput$visNetwork_whole_network_connected_life_events_columns_to_show_UI <- renderUI({tagList(selectInput(\n  'connected_life_events_Cols', 'Columns to show:',\n  usefulCols_life_events, selected = c(\n    \"Primary.Participant.Name\",\"Secondary.Participant.Name\",\"Event.or.Relationship.Type\",\"DateOne.Year\"),\n  multiple = TRUE\n),tags$style(\n  type = \"text/css\", \"select#selCategories + .selectize-control{width: 800px}\"\n))})\n\noutput$visNetwork_whole_network_selected_node <- DT::renderDataTable({\n  \n  #   if(is.null(input$include_interactions_without_dates)){\n  #     return()\n  #   }\n  \n  ## Set selected.interactions as all multiparty.interactions\n  selected.interactions <- multiparty.interactions\n  \n  ## Drop excluded categoties from multiparty interactions\n  selected.interactions <-\n    selected.interactions[selected.interactions$Event.or.Relationship.Type != input$visNetwork_wholeNetwork_ExcludedCategory,]\n  \n  if(!is.null(input$visNetwork_wholeNetwork_show_timeslider)){\n\n    ## Filter out rows where DateOne.Year is NA or outside of date range\n    selected.interactions <- selected.interactions[{selected.interactions$DateOne.Year >= input$visNetwork_wholeNetwork_time_period_of_interest[1]} %in% TRUE & \n    {selected.interactions$DateOne.Year <= input$visNetwork_wholeNetwork_time_period_of_interest[2]} %in% TRUE ,]\n    ## Filter out rows where DateTwo.Year is greater than the max date allowd\n    selected.interactions <- selected.interactions[selected.interactions$DateTwo.Year <= input$visNetwork_wholeNetwork_time_period_of_interest[2] |\n                                                     is.na(selected.interactions$DateTwo.Year),]\n  }\n  \n  # Drop levels that are empty (as a result of above subsetting)\n  selected.interactions <- droplevels(selected.interactions)\n  \n  ## Get selected individual from click\n  nodes <- visNetwork_wholeNetwork_nodes()\n  selectedIndividual <- as.numeric(input$current_node_id$nodes[[1]])\n  \n  # Get edges of network\n  edges <- visNetwork_wholeNetwork_edges()\n  \n  \n  connectedIndividuals <- c(as.character(edges[edges$source.emlo.id == selectedIndividual, \"target.emlo.id\"]),\n                            as.character(edges[edges$target.emlo.id == selectedIndividual, \"source.emlo.id\"]))\n  \n  # Create an empty data.frame with life.event.columns\n  connected_life_events <- selected.interactions[0,]\n  # Function to extract connected events\n  get.connected.life.events <- function(selectedNode, connectedNode){\n    connections <- rbind(\n      selected.interactions[selected.interactions$Primary.Participant.Emlo_ID == selectedNode & \n                              selected.interactions$Secondary.Participant.Emlo_ID == connectedNode,],\n      selected.interactions[selected.interactions$Primary.Participant.Emlo_ID == connectedNode & \n                              selected.interactions$Secondary.Participant.Emlo_ID == selectedNode,]\n    )\n    connected_life_events <<- rbind(connected_life_events, connections)\n  }\n  # lapply function\n  invisible(lapply(connectedIndividuals, function(x)get.connected.life.events(selectedIndividual, x)))\n  \n  \n  # Drop empty rows:\n  connected_life_events <- connected_life_events[!!rowSums(!is.na(connected_life_events)),]\n  # Return\n  connected_life_events[,input$connected_life_events_Cols, drop = FALSE]\n  \n})\n\n### ====================================== Selected Two Individuals Prosopography ============================================\n### =================================================================================================================\n\noutput$visNetwork_selected_individual_show_timeslider_UI <- renderUI({\n  checkboxInput(\"visNetwork_selected_individual_show_timeslider\", \n                label = \"Remove undated interactions and filter by date?\", value = TRUE)\n})\n\n\noutput$visNetwork_selected_individual_time_period_of_interest_UI <- renderUI({\n  \n  if (is.null(input$visNetwork_selected_individual_show_timeslider)) {\n    return()\n  }\n  \n  if (!input$visNetwork_selected_individual_show_timeslider) {\n    return()\n  }\n  \n  dates <-\n    c(multiparty.interactions$DateOne.Year,multiparty.interactions$DateTwo.Year)\n  dates <- dates[!is.na(dates)]\n  \n  # Remove an incorrect date\n  dates <- dates[dates > 1000]\n  \n  sliderInput(\n    \"visNetwork_selected_individual_time_period_of_interest\", \"Time period of interest:\",\n    min = min(dates) - 1,\n    max = max(dates),\n    step = 1,\n    value = c(min(dates), max(dates))\n  )\n})\n\noutput$neighbor.degree.UI <- renderUI({\n  sliderInput(\"neighbor.degree\", label = \"Neighbor Degree\", min = 1, max = 3, value = 1, step = 1)\n})\n\noutput$select.individual.1_UI <- renderUI({\n  \n  if (is.null(input$visNetwork_selected_individual_show_timeslider)) {\n    return()\n  }\n  \n  ## Only include people who are in the multiparty events!\n  people.with.connections <- unique(c(multiparty.interactions$Primary.Participant.Emlo_ID,\n                                      multiparty.interactions$Secondary.Participant.Emlo_ID))\n  \n  people.with.connections <- subset(people.df, iperson_id %in% people.with.connections)\n  \n  ## IF timeline enabled, filter out individuals who are do not appear in life events with DateOne.Year values\n  if(!is.null(input$visNetwork_selected_individual_show_timeslider)){\n    events.with.dates <- multiparty.interactions[!is.na(multiparty.interactions$DateOne.Year),]\n    people.with.dates <- unique(c(events.with.dates$Primary.Participant.Emlo_ID, events.with.dates$Secondary.Participant.Emlo_ID))\n    \n    people.with.connections <- subset(people.with.connections, iperson_id %in% people.with.dates)\n    \n  }\n  \n  labels.list <- as.character(people.with.connections$Person.Name)\n  values.list <- as.list(unlist(as.character(people.with.connections$iperson_id)))\n  \n  names(values.list) <- labels.list\n  \n  selectInput(\"select.individual.1\", label = \"Select individual 1 for prosopography analysis\",\n              choices = values.list, selected = as.character(values.list[1]), multiple = FALSE)\n  })\n\n## Select second individual\noutput$select.individual.2_UI <- renderUI({\n  \n  if (is.null(input$select.individual.1)){\n    return()\n  }\n  \n  people.with.connections <- unique(c(multiparty.interactions$Primary.Participant.Emlo_ID,multiparty.interactions$Secondary.Participant.Emlo_ID))\n  people.with.connections <- subset(people.df, iperson_id %in% people.with.connections)\n  \n  ## IF timeline enabled, filter out individuals who are do not appear in life events with DateOne.Year values\n  if(!is.null(input$visNetwork_selected_individual_show_timeslider)){\n    events.with.dates <- multiparty.interactions[!is.na(multiparty.interactions$DateOne.Year),]\n    people.with.dates <- unique(c(events.with.dates$Primary.Participant.Emlo_ID, events.with.dates$Secondary.Participant.Emlo_ID))\n    \n    people.with.connections <- subset(people.with.connections, iperson_id %in% people.with.dates)\n    \n  }\n  \n  labels.list <- as.character(people.with.connections$Person.Name)\n  values.list <- as.list(unlist(as.character(people.with.connections$iperson_id)))\n  \n  names(values.list) <- labels.list\n  \n  values.list <- values.list[!as.character(values.list) %in% input$select.individual.1]\n  \n  selectInput(\"select.individual.2\", label = \"Select individual 2 for prosopography analysis\",\n              choices = values.list, selected = as.character(values.list[2]), multiple = FALSE)})\n\n## Select third individual\noutput$select.individual.3_UI <- renderUI({\n  \n  if (is.null(input$select.individual.2)){\n    return()\n  }\n  \n  people.with.connections <- unique(c(multiparty.interactions$Primary.Participant.Emlo_ID,multiparty.interactions$Secondary.Participant.Emlo_ID))\n  people.with.connections <- subset(people.df, iperson_id %in% people.with.connections)\n  \n  ## IF timeline enabled, filter out individuals who are do not appear in life events with DateOne.Year values\n  if(!is.null(input$visNetwork_selected_individual_show_timeslider)){\n    events.with.dates <- multiparty.interactions[!is.na(multiparty.interactions$DateOne.Year),]\n    people.with.dates <- unique(c(events.with.dates$Primary.Participant.Emlo_ID, events.with.dates$Secondary.Participant.Emlo_ID))\n    \n    people.with.connections <- subset(people.with.connections, iperson_id %in% people.with.dates)\n    \n  }\n  \n  labels.list <- as.character(people.with.connections$Person.Name)\n  values.list <- as.list(unlist(as.character(people.with.connections$iperson_id)))\n  \n  names(values.list) <- labels.list\n  \n  values.list <- values.list[!as.character(values.list) %in% input$select.individual.2]\n  \n  selectInput(\"select.individual.3\", label = \"Select individual 3 for prosopography analysis\",\n              choices = values.list, selected = as.character(values.list[3]), multiple = FALSE)})\n\nselect.individual.edges <- reactive({\n\n  if (is.null(input$select.individual.2)){\n    return()\n  }\n#   \n#   ## Test suite\n#   selected.individual.1 <- \"908078\"\n#   selected.individual.2 <- \"300007\"\n   \n  selected.individual.1 <- input$select.individual.1\n  selected.individual.2 <- input$select.individual.2\n  selected.individual.3 <- input$select.individual.3\n  \n  selected.interactions <- multiparty.interactions\n  \n  ## If timeline enabled, filter out individuals \n  if(!is.null(input$visNetwork_selected_individual_show_timeslider)){\n    \n    ## Filter out rows where DateOne.Year is NA or outside of date range\n    selected.interactions <- selected.interactions[{selected.interactions$DateOne.Year >= input$visNetwork_selected_individual_time_period_of_interest[1]} %in% TRUE & \n    {selected.interactions$DateOne.Year <= input$visNetwork_selected_individual_time_period_of_interest[2]} %in% TRUE ,]\n    ## Filter out rows where DateTwo.Year is greater than the max date allowd\n    selected.interactions <- selected.interactions[selected.interactions$DateTwo.Year <= input$visNetwork_selected_individual_time_period_of_interest[2] |\n                                                     is.na(selected.interactions$DateTwo.Year),]\n  }\n  \n  ## Generate edges\n  edges <- network.edges.function(selected.interactions)\n  ## Get just edges for igraph\n  edges <- edges[,c(\"Primary.Emlo_ID\",\"Secondary.Emlo_ID\")]\n  ## Extract nodes\n  nodes <- unique(c(edges$Primary.Emlo_ID,edges$Secondary.Emlo_ID))\n  ## Generate igraph\n  igraph.for.computation <- graph.data.frame(edges, nodes, directed = FALSE)\n  ## plot igraph\n  # plot(igraph.for.computation, vertex.size=2, vertex.label=NA, edge.arrow.size=.2)\n  \n  ## Set graph.union.fail to FALSE\n  graph.union.fail <- FALSE\n  \n  ## Use tryCatch for errors when no connected edges found!\n  tryCatch(neighboring_nodes <- \n             ## Find neihbouring nodes, graph.union is needed as make_ego_graph outputs a list of graph\n             graph.union(make_ego_graph(igraph.for.computation, \n                                                           order = input$neighbor.degree, \n                                                           nodes = c(selected.individual.1, \n                                                                     selected.individual.2,\n                                                                     selected.individual.3))),\n           error = function(e){\n             graph.union.fail <<- TRUE\n           })\n  print(graph.union.fail)\n  if(graph.union.fail){\n    visN_edges <- \"graph.union.fail\"\n    return()\n  }\n  \n  # plot igraph of neighboring vertices\n  # plot(neighboring_nodes,vertex.size=2, vertex.label=V(neighboring_nodes)$name, edge.arrow.size=.2)\n  \n  ## Subset multiparty.interactions by the node names:\n  selected.interactions <- subset(multiparty.interactions, Primary.Participant.Emlo_ID %in% V(neighboring_nodes)$name &\n                                    Secondary.Participant.Emlo_ID %in% V(neighboring_nodes)$name)\n  \n  ## Generates edges for visNetwork\n  visN_edges <- network.edges.function(selected.interactions)\n  \n  ## Return dataframe\n  visN_edges\n})\n\n## show warning if no edges to display\noutput$selected.individual.network_no_graph <- renderUI({\n  ## If not loaded yet, stop\n  if (is.null(input$select.individual.3)){\n    return()\n  }\n  \n  visN_edges <- select.individual.edges()\n  ## If graph.union.fail then the visN_edges is null\n  if(is.null(visN_edges)){\n    wellPanel(\n      \"There are\n      no known connections between the individuals selected, subject to the current filter conditions.\"\n    )\n  }\n}\n)\n\n## Show connections between selected individuals\noutput$select.individual.network_graph <- renderVisNetwork({\n  \n  ## If not loaded yet, stop\n  if (is.null(input$select.individual.3)){\n    return()\n  }\n  \n  ## load visN_edges\n  visN_edges <- select.individual.edges()\n\n  ## If graph.union.fail then the visN_edges is null\n  if(is.null(visN_edges)){\n    return()\n  }\n  \n  visN_edges <- data.frame(\"from\" = visN_edges$Primary.Emlo_ID,\n                           \"to\" = visN_edges$Secondary.Emlo_ID,stringsAsFactors = FALSE)\n\n  \n  ## Subset people.df by the nodes appearing in the edges:\n  visN_nodes <- subset(people.df, iperson_id %in% unique(c(visN_edges$from,visN_edges$to)))\n  \n  ## Pull out data for visNetwork\n  visN_nodes <- data.frame(\"id\" = visN_nodes$iperson_id,\n                           \"title\" = visN_nodes$Person.Name,\n                           \"label\" = visN_nodes$Surname)\n  \n  ## Highlight the selected nodes as red\n  node_colors <- rep(\"lightblue\",nrow(visN_nodes))\n  node_colors[match(c(input$select.individual.1,input$select.individual.2,input$select.individual.3), visN_nodes$id)] <- \"red\"\n  \n  visN_nodes$color <- node_colors\n  \n  ## Remove duplicated nodes\n  visN_nodes <- visN_nodes[!duplicated(visN_nodes$id),]\n  \n  ## Drop edges with nodes not in the node list\n  non.conflicting.nodes <- intersect(unique(c(visN_edges$from, visN_edges$to)), visN_nodes$id)\n  visN_edges <- subset(visN_edges, from %in% non.conflicting.nodes & to %in% non.conflicting.nodes)\n  \n  ## Visualise\n  \n  visNetwork(visN_nodes, visN_edges) %>% \n    visNodes(color = list(background = \"lightblue\", border = \"darkblue\"),size = 10) %>% \n    visIgraphLayout() %>%\n    visInteraction(tooltipDelay = 0.2, hideEdgesOnDrag = TRUE, dragNodes = FALSE, dragView = FALSE, zoomView = TRUE) %>%\n    visOptions(highlightNearest = TRUE) %>%\n    visLayout(hierarchical = FALSE) %>% visInteraction(navigationButtons = TRUE) %>%\n    visEvents(selectNode = \"function(nodes) {\n                Shiny.onInputChange('current_node_id', nodes);\n                ;}\")\n})\n\n\n",
    "created" : 1454875094668.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "47|4|104|1|\n456|4|724|2|\n",
    "hash" : "3377232082",
    "id" : "708A5E23",
    "lastKnownWriteTime" : 1454883805,
    "path" : "~/Github/Live-Data_Case-Studies/2016 Case Studies/Cultures-of-Knowledge/server/visualisations-and-ui.R",
    "project_path" : "server/visualisations-and-ui.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}