output$trendPlot <- renderPlotly({
# size of the bins depend on the input 'bins'
size <- (maxx - minx) / input$bins
# a simple histogram of movie ratings
p <- plot_ly(movies, x = rating, autobinx = F, type = "histogram",
xbins = list(start = minx, end = maxx, size = size))
# style the xaxis
layout(p, xaxis = list(title = "Ratings", range = c(minx, maxx), autorange = F,
autotick = F, tick0 = minx, dtick = size))
})
}
)
shinyApp(
ui = fluidPage(
titlePanel("Movie Ratings!"),
sidebarPanel(
sliderInput("bins", "Number of bins:", min = 1, max = 50, value = 10)
),
mainPanel(
plotlyOutput("trendPlot")
)
),
server = function(input, output) {
output$trendPlot <- renderPlotly({
# size of the bins depend on the input 'bins'
size <- (maxx - minx) / input$bins
# a simple histogram of movie ratings
p <- plot_ly(movies, x = rating, autobinx = F, type = "histogram",
xbins = list(start = minx, end = maxx, size = size))
# style the xaxis
layout(p, xaxis = list(title = "Ratings", range = c(minx, maxx), autorange = F,
autotick = F, tick0 = minx, dtick = size))
})
}
)
library(plotly)
library(googlesheets)
Sys.setenv("plotly_username"="martinjhnhadley")
Sys.setenv("plotly_api_key"="kjtdc13pte")
library(shiny)
shinyApp(
ui = fluidPage(
sliderInput("ndata","Number of Data",min = 10, max = 1000, value = 500, step = 1),
plotOutput("hist")
),
server = function(input, output, session){
output$hist <- renderPlot(hist(rnorm(input$ndata), xlab = "Value", main = "Histogram of random variates from normal distribution"), height = 300)
}
)
library(shiny)
# which fields get saved
fieldsAll <- c("name", "favourite_pkg", "used_shiny", "r_num_years", "os_type")
# which fields are mandatory
fieldsMandatory <- c("name", "favourite_pkg")
# add an asterisk to an input label
labelMandatory <- function(label) {
tagList(
label,
span("*", class = "mandatory_star")
)
}
# get current Epoch time
epochTime <- function() {
return(as.integer(Sys.time()))
}
# get a formatted string of the timestamp (exclude colons as they are invalid
# characters in Windows filenames)
humanTime <- function() {
format(Sys.time(), "%Y%m%d-%H%M%OS")
}
# save the results to a file
saveData <- function(data) {
fileName <- sprintf("%s_%s.csv",
humanTime(),
digest::digest(data))
write.csv(x = data, file = file.path(responsesDir, fileName),
row.names = FALSE, quote = TRUE)
}
# load all responses into a data.frame
loadData <- function() {
files <- list.files(file.path(responsesDir), full.names = TRUE)
data <- lapply(files, read.csv, stringsAsFactors = FALSE)
#data <- dplyr::rbind_all(data)
data <- do.call(rbind, data)
data
}
# directory where responses get stored
responsesDir <- file.path("responses")
# CSS to use in the app
appCSS <-
".mandatory_star { color: red; }
.shiny-input-container { margin-top: 25px; }
#submit_msg { margin-left: 15px; }
#error { color: red; }
#adminPanel { border: 4px solid #aaa; padding: 0 20px 20px; }"
# usernames that are admins
adminUsers <- c("admin", "prof")
shinyApp(
ui = fluidPage(
shinyjs::useShinyjs(),
shinyjs::inlineCSS(appCSS),
titlePanel("Mimicking a Google Form with a Shiny app"),
h3("This app is a supplement to my",
a(href = "http://deanattali.com/2015/06/14/mimicking-google-form-shiny/",
"blog post on the topic")
),
fluidRow(
column(6,
div(
id = "form",
textInput("name", labelMandatory("Name"), ""),
textInput("favourite_pkg", labelMandatory("Favourite R package")),
checkboxInput("used_shiny", "I've built a Shiny app in R before", FALSE),
sliderInput("r_num_years", "Number of years using R", 0, 25, 2, ticks = FALSE),
selectInput("os_type", "Operating system used most frequently",
c("",  "Windows", "Mac", "Linux")),
actionButton("submit", "Submit", class = "btn-primary"),
shinyjs::hidden(
span(id = "submit_msg", "Submitting..."),
div(id = "error",
div(br(), tags$b("Error: "), span(id = "error_msg"))
)
)
),
shinyjs::hidden(
div(
id = "thankyou_msg",
h3("Thanks, your response was submitted successfully!"),
actionLink("submit_another", "Submit another response")
)
)
),
column(6,
uiOutput("adminPanelContainer")
)
)
),
server = function(input, output, session) {
# Enable the Submit button when all mandatory fields are filled out
observe({
mandatoryFilled <-
vapply(fieldsMandatory,
function(x) {
!is.null(input[[x]]) && input[[x]] != ""
},
logical(1))
mandatoryFilled <- all(mandatoryFilled)
shinyjs::toggleState(id = "submit", condition = mandatoryFilled)
})
# Gather all the form inputs (and add timestamp)
formData <- reactive({
data <- sapply(fieldsAll, function(x) input[[x]])
data <- c(data, timestamp = epochTime())
data <- t(data)
data
})
# When the Submit button is clicked, submit the response
observeEvent(input$submit, {
# User-experience stuff
shinyjs::disable("submit")
shinyjs::show("submit_msg")
shinyjs::hide("error")
# Save the data (show an error message in case of error)
tryCatch({
saveData(formData())
shinyjs::reset("form")
shinyjs::hide("form")
shinyjs::show("thankyou_msg")
},
error = function(err) {
shinyjs::text("error_msg", err$message)
shinyjs::show(id = "error", anim = TRUE, animType = "fade")
},
finally = {
shinyjs::enable("submit")
shinyjs::hide("submit_msg")
})
})
# submit another response
observeEvent(input$submit_another, {
shinyjs::show("form")
shinyjs::hide("thankyou_msg")
})
# render the admin panel
output$adminPanelContainer <- renderUI({
if (!isAdmin()) return()
div(
id = "adminPanel",
h2("Previous responses (only visible to admins)"),
downloadButton("downloadBtn", "Download responses"), br(), br(),
DT::dataTableOutput("responsesTable")
)
})
# determine if current user is admin
isAdmin <- reactive({
is.null(session$user) || session$user %in% adminUsers
})
# Show the responses in the admin table
output$responsesTable <- DT::renderDataTable(
loadData(),
rownames = FALSE,
options = list(searching = FALSE, lengthChange = FALSE)
)
# Allow user to download responses
output$downloadBtn <- downloadHandler(
filename = function() {
sprintf("mimic-google-form_%s.csv", humanTime())
},
content = function(file) {
write.csv(loadData(), file, row.names = FALSE)
}
)
}
)
devtools::install_github("ropensci/plotly")
library(plotly)
p <- plot_ly(midwest, x = percollege, color = state, type = "box")
p
M0 <- matrix(c('Label','Value'),ncol=2,byrow=TRUE)
M1 <- matrix(c('IRR',4),ncol=2,byrow=TRUE)
MU <- rbind(M0,M1)
df <- as.data.frame(MU)
library(shiny)
library(googleVis)
runApp(list(
ui = bootstrapPage(
numericInput('n', 'Number of obs', 4, 1, 10),
htmlOutput("view")
),
server = function(input, output) {
output$view <- renderGvis({
df <- data.frame(Label = "IRR", Value = input$n)
gvisGauge(df,
options=list(min=0, max=10, greenFrom=8,
greenTo=10, yellowFrom=6, yellowTo=8,
redFrom=0, redTo=6, width=300, height=300));
})
}
))
Gauge1 <- gvisGauge(CityPopularity, options=list(min=0, max=800, greenFrom=500,
greenTo=800, yellowFrom=300, yellowTo=500,
redFrom=0, redTo=300))
plot(Gauge1)
library(shiny)
library(plotly)
shinyApp(
ui = fluidPage(
titlePanel("Movie Ratings!"),
sidebarPanel(
sliderInput("bins", "Number of bins:", min = 1, max = 50, value = 10)
),
mainPanel(
plotlyOutput("trendPlot")
)
),
server = function(input, output) {
output$trendPlot <- renderPlotly({
# size of the bins depend on the input 'bins'
size <- (maxx - minx) / input$bins
# a simple histogram of movie ratings
p <- plot_ly(movies, x = rating, autobinx = F, type = "histogram",
xbins = list(start = minx, end = maxx, size = size))
# style the xaxis
layout(p, xaxis = list(title = "Ratings", range = c(minx, maxx), autorange = F,
autotick = F, tick0 = minx, dtick = size))
})
}
)
data(movies, package = "ggplot2")
minx <- min(movies$rating)
maxx <- max(movies$rating)
shinyApp(
ui = fluidPage(
titlePanel("Movie Ratings!"),
sidebarPanel(
sliderInput("bins", "Number of bins:", min = 1, max = 50, value = 10)
),
mainPanel(
plotlyOutput("trendPlot")
)
),
server = function(input, output) {
output$trendPlot <- renderPlotly({
# size of the bins depend on the input 'bins'
size <- (maxx - minx) / input$bins
# a simple histogram of movie ratings
p <- plot_ly(movies, x = rating, autobinx = F, type = "histogram",
xbins = list(start = minx, end = maxx, size = size))
# style the xaxis
layout(p, xaxis = list(title = "Ratings", range = c(minx, maxx), autorange = F,
autotick = F, tick0 = minx, dtick = size))
})
}
)
source('~/.active-rstudio-document')
shiny::runApp('Github/Rmd-and-Shiny-Templates/Shiny-Templates/Large-Apps')
shiny::runApp('Github/Rmd-and-Shiny-Templates/Shiny-Templates/Large-Apps')
shiny::runApp('Github/Rmd-and-Shiny-Templates/Shiny-Templates/Large-Apps')
shiny::runApp('Github/Rmd-and-Shiny-Templates/Shiny-Templates/Large-Apps')
shiny::runApp('Github/Rmd-and-Shiny-Templates/Shiny-Templates/Large-Apps')
shiny::runApp('Github/Rmd-and-Shiny-Templates/Shiny-Templates/Large-Apps')
shiny::runApp('Dropbox/Live-Data/Vili-VirtualEconomistsData/VirtualEconomies')
shiny::runApp('Downloads/617cfb1d63ee4f6789da8a0a4df64682 2')
if (interactive()) {
ui <- fluidPage(
column(4,
numericInput("x", "Value", 5),
br(),
actionButton("button", "Show")
),
column(8, tableOutput("table"))
)
server <- function(input, output) {
# Take an action every time button is pressed;
# here, we just print a message to the console
observeEvent(input$button, {
cat("Showing", input$x, "rows\n")
})
# Take a reactive dependency on input$button, but
# not on any of the stuff inside the function
df <- eventReactive(input$button, {
head(cars, input$x)
})
output$table <- renderTable({
df()
})
}
shinyApp(ui=ui, server=server)
}
library(shiny)
if (interactive()) {
ui <- fluidPage(
column(4,
numericInput("x", "Value", 5),
br(),
actionButton("button", "Show")
),
column(8, tableOutput("table"))
)
server <- function(input, output) {
# Take an action every time button is pressed;
# here, we just print a message to the console
observeEvent(input$button, {
cat("Showing", input$x, "rows\n")
})
# Take a reactive dependency on input$button, but
# not on any of the stuff inside the function
df <- eventReactive(input$button, {
head(cars, input$x)
})
output$table <- renderTable({
df()
})
}
shinyApp(ui=ui, server=server)
}
if (interactive()) {
ui <- fluidPage(
column(4,
numericInput("x", "Value", 5),
br(),
numericInput("y", "Value", 5,)
actionButton("button", "Show")
),
column(8, tableOutput("table"))
)
server <- function(input, output) {
# Take an action every time button is pressed;
# here, we just print a message to the console
observeEvent(c(input$button,input$y), {
cat("Showing", input$x, "rows\n")
})
# Take a reactive dependency on input$button, but
# not on any of the stuff inside the function
df <- eventReactive(input$button, {
head(cars, input$x)
})
output$table <- renderTable({
df()
})
}
shinyApp(ui=ui, server=server)
if (interactive()) {
ui <- fluidPage(
column(4,
numericInput("x", "Value", 5),
br(),
numericInput("y", "Value", 5,),
actionButton("button", "Show")
),
column(8, tableOutput("table"))
)
server <- function(input, output) {
# Take an action every time button is pressed;
# here, we just print a message to the console
observeEvent(c(input$button,input$y), {
cat("Showing", input$x, "rows\n")
})
# Take a reactive dependency on input$button, but
# not on any of the stuff inside the function
df <- eventReactive(input$button, {
head(cars, input$x)
})
output$table <- renderTable({
df()
})
}
shinyApp(ui=ui, server=server)
}
if (interactive()) {
ui <- fluidPage(
column(4,
numericInput("x", "Value", 5),
br(),
numericInput("y", "Value", 5,),
actionButton("button", "Show")
),
column(8, tableOutput("table"))
)
server <- function(input, output) {
# Take an action every time button is pressed;
# here, we just print a message to the console
observeEvent(c(input$button,input$y), {
cat("Showing", input$x, "rows\n")
})
# Take a reactive dependency on input$button, but
# not on any of the stuff inside the function
df <- eventReactive(c(input$button,input$y), {
head(cars, input$x)
})
output$table <- renderTable({
df()
})
}
shinyApp(ui=ui, server=server)
}
master <- letters()
master <- letters
master <- data.frame("a" = letters,
"b" = 1:26)
subset(master, a %in% c("b", "c"))
subset(master, a %in% c("b", "c") &
b %in% c("e","g"))
subset(master, a %in% c("b", "c") &
a %in% c("e","g"))
subset(master, a %in% c("b", "c") & a %in% c("e","g"))
subset(master, a %in% c(c("b", "c"),c("e","g")))
edges <- read.csv("data/primatology-edges_wAttributes.csv", header=T, as.is=T)
setwd("~/Dropbox/Live-Data/Migration_ Viz/Felix-Krawatzek_Politics-Maps/Conversation-Article/world-timeline")
### ============= Data Processing Task 1 ========================= ###
### Commented out due to slow import ###
# library(xlsx)
# letters_maxqda_import <- read.xlsx("Letters MaxQDA Format.xls", sheetIndex = 1)
# write.csv(letters_maxqda_import, file = "latters-MaxQDA-Format.csv")
# Import csv file
letters_maxqda_import <- read.csv(file ="data/latters-MaxQDA-Format.csv", stringsAsFactors = FALSE)
# drop rows with empty longitudes/latitudes
entries.with.locations <- letters_maxqda_import[!is.na(letters_maxqda_import$Sender.Location.GIS.Latitude) &
!is.na(letters_maxqda_import$Sender.Location.GIS.Longitude) &
!is.na(letters_maxqda_import$Receiver.Location.GIS.Latitude) &
!is.na(letters_maxqda_import$Receiver.Location.GIS.Longitude),]
### ============= Add columns with combined coords for simpler processing later
entries.with.locations$Sender.LatLong.String <- paste(
entries.with.locations$Sender.Location.GIS.Latitude,
entries.with.locations$Sender.Location.GIS.Longitude)
entries.with.locations$Receiver.LatLong.String <- paste(
entries.with.locations$Receiver.Location.GIS.Latitude,
entries.with.locations$Receiver.Location.GIS.Longitude)
## as.character for easier processing
entries.with.locations$Receiver.LatLong.String <- as.character(entries.with.locations$Receiver.LatLong.String)
entries.with.locations$Sender.LatLong.String <- as.character(entries.with.locations$Sender.LatLong.String)
## Drop element where send == receive
entries.with.locations <- entries.with.locations[entries.with.locations$Sender.LatLong.String != entries.with.locations$Receiver.LatLong.String,]
## Interpret dates as dmy and force as GMT
entries.with.locations$Date <- force_tz(dmy(entries.with.locations$Date, quiet = TRUE), tzone = "GMT")
## Find any dates in the future
future.test <- entries.with.locations$Date > as.POSIXct("2016/01/01")
## Remove these dates!
entries.with.locations <- entries.with.locations[!mapvalues(future.test, c(FALSE,NA,TRUE),c(FALSE,FALSE,TRUE)),]
### ===== OLD =====
# ## find ill-defined dates
# suppressWarnings(dates_as_dates <- dmy(entries.with.locations$Date, quiet = TRUE))
# ## Drop ill-defined dates
# entries.with.locations <- entries.with.locations[!is.na(dates_as_dates),]
# ## Interpret dates as dmy and force as GMT
# entries.with.locations$Date <- force_tz(dmy(entries.with.locations$Date, quiet = TRUE), tzone = "GMT")
# ## Remove date in the future!
# entries.with.locations <- entries.with.locations[entries.with.locations$Date < as.POSIXct("2016/01/01"),]
## Make a set of location -> name replacements
location_name_df <- data.frame("LatLong" = c(entries.with.locations$Sender.LatLong.String,entries.with.locations$Receiver.LatLong.String),
"Location.Name" = c(entries.with.locations$Sender.Location, entries.with.locations$Receiver.Location))
### ============= Find duplicate locations
location_name_df <- location_name_df[!duplicated(location_name_df),]
location_name_df$LatLong <- as.character(location_name_df$LatLong)
location_name_df$Location.Name <- as.character(location_name_df$Location.Name)
duplicate_locations <- subset(location_name_df, LatLong %in% location_name_df[duplicated(location_name_df$LatLong),]$LatLong)
# Remove duplicates
location_name_df <- location_name_df[!duplicated(location_name_df$LatLong),]
### ============= Letter Series
entries.with.locations$Letter.Series <- as.factor(entries.with.locations$Letter.Series)
### ============= Data Processing Task 2 ========================= ###
## ==== Packages to load for server
library(shiny) # Some advanced functionality depends on the shiny package being loaded server-side, including plot.ly
library(plotly)
library(scales)
library(dplyr)
library(plyr)
library(lubridate)
shiny::runApp()
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
